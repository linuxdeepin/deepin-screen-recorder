/*
 * This file was generated by qdbusxml2cpp-fix version 0.8
 * Command line was: qdbusxml2cpp-fix -c Audio -p generated/com_deepin_daemon_audio ../xml/com.deepin.daemon.Audio.xml
 *
 * qdbusxml2cpp-fix is Copyright (C) 2016 Deepin Technology Co., Ltd.
 *
 * This is an auto-generated file.
 * This file may have been hand-edited. Look for HAND-EDIT comments
 * before re-generating it.
 */

#include "generated/com_deepin_daemon_audio.h"

/*
 * Implementation of interface class __Audio
 */

class __AudioPrivate
{
public:
   __AudioPrivate() = default;

    // begin member variables
    QString BluetoothAudioMode;
    QStringList BluetoothAudioModeOpts;
    QString Cards;
    QString CardsWithoutUnavailable;
    QDBusObjectPath DefaultSink;
    QDBusObjectPath DefaultSource;
    bool IncreaseVolume;
    double MaxUIVolume;
    bool ReduceNoise;
    QList<QDBusObjectPath> SinkInputs;
    QList<QDBusObjectPath> Sinks;
    QList<QDBusObjectPath> Sources;

public:
    QMap<QString, QDBusPendingCallWatcher *> m_processingCalls;
    QMap<QString, QList<QVariant>> m_waittingCalls;
};

__Audio::__Audio(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
    : DBusExtendedAbstractInterface(service, path, staticInterfaceName(), connection, parent)
    , d_ptr(new __AudioPrivate)
{
    connect(this, &__Audio::propertyChanged, this, &__Audio::onPropertyChanged);

}

__Audio::~__Audio()
{
    qDeleteAll(d_ptr->m_processingCalls.values());
    delete d_ptr;
}

void __Audio::onPropertyChanged(const QString &propName, const QVariant &value)
{
    if (propName == QStringLiteral("BluetoothAudioMode"))
    {
        const QString &BluetoothAudioMode = qvariant_cast<QString>(value);
        if (d_ptr->BluetoothAudioMode != BluetoothAudioMode)
        {
            d_ptr->BluetoothAudioMode = BluetoothAudioMode;
            Q_EMIT BluetoothAudioModeChanged(d_ptr->BluetoothAudioMode);
        }
        return;
    }

    if (propName == QStringLiteral("BluetoothAudioModeOpts"))
    {
        const QStringList &BluetoothAudioModeOpts = qvariant_cast<QStringList>(value);
        if (d_ptr->BluetoothAudioModeOpts != BluetoothAudioModeOpts)
        {
            d_ptr->BluetoothAudioModeOpts = BluetoothAudioModeOpts;
            Q_EMIT BluetoothAudioModeOptsChanged(d_ptr->BluetoothAudioModeOpts);
        }
        return;
    }

    if (propName == QStringLiteral("Cards"))
    {
        const QString &Cards = qvariant_cast<QString>(value);
        if (d_ptr->Cards != Cards)
        {
            d_ptr->Cards = Cards;
            Q_EMIT CardsChanged(d_ptr->Cards);
        }
        return;
    }

    if (propName == QStringLiteral("CardsWithoutUnavailable"))
    {
        const QString &CardsWithoutUnavailable = qvariant_cast<QString>(value);
        if (d_ptr->CardsWithoutUnavailable != CardsWithoutUnavailable)
        {
            d_ptr->CardsWithoutUnavailable = CardsWithoutUnavailable;
            Q_EMIT CardsWithoutUnavailableChanged(d_ptr->CardsWithoutUnavailable);
        }
        return;
    }

    if (propName == QStringLiteral("DefaultSink"))
    {
        const QDBusObjectPath &DefaultSink = qvariant_cast<QDBusObjectPath>(value);
        if (d_ptr->DefaultSink != DefaultSink)
        {
            d_ptr->DefaultSink = DefaultSink;
            Q_EMIT DefaultSinkChanged(d_ptr->DefaultSink);
        }
        return;
    }

    if (propName == QStringLiteral("DefaultSource"))
    {
        const QDBusObjectPath &DefaultSource = qvariant_cast<QDBusObjectPath>(value);
        if (d_ptr->DefaultSource != DefaultSource)
        {
            d_ptr->DefaultSource = DefaultSource;
            Q_EMIT DefaultSourceChanged(d_ptr->DefaultSource);
        }
        return;
    }

    if (propName == QStringLiteral("IncreaseVolume"))
    {
        const bool &IncreaseVolume = qvariant_cast<bool>(value);
        if (d_ptr->IncreaseVolume != IncreaseVolume)
        {
            d_ptr->IncreaseVolume = IncreaseVolume;
            Q_EMIT IncreaseVolumeChanged(d_ptr->IncreaseVolume);
        }
        return;
    }

    if (propName == QStringLiteral("MaxUIVolume"))
    {
        const double &MaxUIVolume = qvariant_cast<double>(value);
        if (d_ptr->MaxUIVolume != MaxUIVolume)
        {
            d_ptr->MaxUIVolume = MaxUIVolume;
            Q_EMIT MaxUIVolumeChanged(d_ptr->MaxUIVolume);
        }
        return;
    }

    if (propName == QStringLiteral("ReduceNoise"))
    {
        const bool &ReduceNoise = qvariant_cast<bool>(value);
        if (d_ptr->ReduceNoise != ReduceNoise)
        {
            d_ptr->ReduceNoise = ReduceNoise;
            Q_EMIT ReduceNoiseChanged(d_ptr->ReduceNoise);
        }
        return;
    }

    if (propName == QStringLiteral("SinkInputs"))
    {
        const QList<QDBusObjectPath> &SinkInputs = qvariant_cast<QList<QDBusObjectPath>>(value);
        if (d_ptr->SinkInputs != SinkInputs)
        {
            d_ptr->SinkInputs = SinkInputs;
            Q_EMIT SinkInputsChanged(d_ptr->SinkInputs);
        }
        return;
    }

    if (propName == QStringLiteral("Sinks"))
    {
        const QList<QDBusObjectPath> &Sinks = qvariant_cast<QList<QDBusObjectPath>>(value);
        if (d_ptr->Sinks != Sinks)
        {
            d_ptr->Sinks = Sinks;
            Q_EMIT SinksChanged(d_ptr->Sinks);
        }
        return;
    }

    if (propName == QStringLiteral("Sources"))
    {
        const QList<QDBusObjectPath> &Sources = qvariant_cast<QList<QDBusObjectPath>>(value);
        if (d_ptr->Sources != Sources)
        {
            d_ptr->Sources = Sources;
            Q_EMIT SourcesChanged(d_ptr->Sources);
        }
        return;
    }

    qWarning() << "property not handle: " << propName;
    return;
}

QString __Audio::bluetoothAudioMode()
{
    return qvariant_cast<QString>(internalPropGet("BluetoothAudioMode", &d_ptr->BluetoothAudioMode));
}

QStringList __Audio::bluetoothAudioModeOpts()
{
    return qvariant_cast<QStringList>(internalPropGet("BluetoothAudioModeOpts", &d_ptr->BluetoothAudioModeOpts));
}

QString __Audio::cards()
{
    return qvariant_cast<QString>(internalPropGet("Cards", &d_ptr->Cards));
}

QString __Audio::cardsWithoutUnavailable()
{
    return qvariant_cast<QString>(internalPropGet("CardsWithoutUnavailable", &d_ptr->CardsWithoutUnavailable));
}

QDBusObjectPath __Audio::defaultSink()
{
    return qvariant_cast<QDBusObjectPath>(internalPropGet("DefaultSink", &d_ptr->DefaultSink));
}

QDBusObjectPath __Audio::defaultSource()
{
    return qvariant_cast<QDBusObjectPath>(internalPropGet("DefaultSource", &d_ptr->DefaultSource));
}

bool __Audio::increaseVolume()
{
    return qvariant_cast<bool>(internalPropGet("IncreaseVolume", &d_ptr->IncreaseVolume));
}

void __Audio::setIncreaseVolume(bool value)
{

   internalPropSet("IncreaseVolume", QVariant::fromValue(value), &d_ptr->IncreaseVolume);
}

double __Audio::maxUIVolume()
{
    return qvariant_cast<double>(internalPropGet("MaxUIVolume", &d_ptr->MaxUIVolume));
}

bool __Audio::reduceNoise()
{
    return qvariant_cast<bool>(internalPropGet("ReduceNoise", &d_ptr->ReduceNoise));
}

void __Audio::setReduceNoise(bool value)
{

   internalPropSet("ReduceNoise", QVariant::fromValue(value), &d_ptr->ReduceNoise);
}

QList<QDBusObjectPath> __Audio::sinkInputs()
{
    return qvariant_cast<QList<QDBusObjectPath>>(internalPropGet("SinkInputs", &d_ptr->SinkInputs));
}

QList<QDBusObjectPath> __Audio::sinks()
{
    return qvariant_cast<QList<QDBusObjectPath>>(internalPropGet("Sinks", &d_ptr->Sinks));
}

QList<QDBusObjectPath> __Audio::sources()
{
    return qvariant_cast<QList<QDBusObjectPath>>(internalPropGet("Sources", &d_ptr->Sources));
}

void __Audio::CallQueued(const QString &callName, const QList<QVariant> &args)
{
    if (d_ptr->m_waittingCalls.contains(callName))
    {
        d_ptr->m_waittingCalls[callName] = args;
        return;
    }
    if (d_ptr->m_processingCalls.contains(callName))
    {
        d_ptr->m_waittingCalls.insert(callName, args);
    } else {
        QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(asyncCallWithArgumentList(callName, args));
        connect(watcher, &QDBusPendingCallWatcher::finished, this, &__Audio::onPendingCallFinished);
        d_ptr->m_processingCalls.insert(callName, watcher);
    }
}

void __Audio::onPendingCallFinished(QDBusPendingCallWatcher *w)
{
    w->deleteLater();
    const auto callName = d_ptr->m_processingCalls.key(w);
    Q_ASSERT(!callName.isEmpty());
    if (callName.isEmpty())
        return;
    d_ptr->m_processingCalls.remove(callName);
    if (!d_ptr->m_waittingCalls.contains(callName))
        return;
    const auto args = d_ptr->m_waittingCalls.take(callName);
    CallQueued(callName, args);
}
